package life.expert.value.string;









import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Singular;
import lombok.Value;
import lombok.extern.slf4j.Slf4j;
import lombok.NonNull;

import io.vavr.Tuple;
import io.vavr.Tuple2;
import io.vavr.match.annotation.Patterns;
import io.vavr.match.annotation.Unapply;


import java.util.Comparator;

import com.google.common.collect.ComparisonChain;

import java.util.List;


import lombok.NonNull;//@NOTNULL

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import static java.text.MessageFormat.format;           //format string

import java.util.ResourceBundle;

import static com.google.common.base.Preconditions.*;   //checkArgument
//import static life.expert.common.base.Preconditions.*;  //checkCollection
import static org.apache.commons.lang3.Validate.*;      //notEmpty(collection)

import org.apache.commons.lang3.StringUtils;            //isNotBlank


import java.util.function.*;                            //producer supplier

import static java.util.stream.Collectors.*;            //toList streamAPI
import static java.util.function.Predicate.*;           //isEqual streamAPI

import java.util.Optional;



import static reactor.core.publisher.Mono.*;
import static reactor.core.scheduler.Schedulers.*;
import static life.expert.common.async.LogUtils.*;        //logAtInfo
import static life.expert.common.function.NullableUtils.*;//.map(nullableFunction)
import static life.expert.common.base.Objects.*;          //deepCopyOfObject

import static io.vavr.API.*;                              //switch
import static io.vavr.Predicates.*;                       //switch - case
import static io.vavr.Patterns.*;                         //switch - case - success/failure
import static cyclops.control.Trampoline.more;
import static cyclops.control.Trampoline.done;



//import java.util.List;                                  //usual list
//import io.vavr.collection.List;                         //immutable List
//import com.google.common.collect.*;                     //ImmutableList

//@Header@
//--------------------------------------------------------------------------------
//
//                          himalaya  life.expert.value.string
//                           wilmer 2019/05/12
//
//--------------------------------------------------------------------------------



//<editor-fold desc=".">
 /*
    @Value означает
        @ToString
        @EqualsAndHashCode
        @AllArgsConstructor
        @FieldDefaults(makeFinal = true, level = AccessLevel.PRIVATE)
        @Getter
        
        
 
     d) IDE autogenerated Guava ComparisonChain, в сгенерированном методе compareTo необходимо заменить:
    		                      .compare( this.item2s ,
		                                that.item2s ,
		                                Ordering.< String > natural().lexicographical() )
		                                
		                                
		                                
		                                
  a) чтобы нельзя было отнаследовать и затереть данные подкласса ВЫБРАН ВАРИАНТ Б)
		вариант а) сделать класс final
		вариант  б) закрыть ВСЕ конструкторы и получать объекты только фабрикой
 
      b) You can use mutable variant of the class (companien class) for batch operations
 
 
 	 c) копирующие фабрики: для немутабельных классов нет смысла поддерживать копирование объектов, поскольку копии будут фактически неотличимы от оригинала.
	   - для немутабельных классов статические методы генерации копии имеют смысл, если получают на вход  параметр более общего интерфейса и мутабельный аргумент (см как в коллекциях Java)
	   - они называются conversion constructors / conversion factories
 
    
    e) нет конструкторов, только статик фабрика и builder
    
f) дефолтные значения свойств можно выставить
	@Builder.Default private final long created = System.currentTimeMillis();

g) как сделать withName метод (если поместить на весь класс - то будет сгенерено для всех методов класса )
	@Wither private final String name;

h) отдельный под-билдер для свойства-коллекции, имплементация будет Guava's ImmutableList
	@Singular  List<Line> ones; // на конце должно быть S, иначе не сможет сделать форму единственного числа
	@Singular("axis") List<Line> axes  // можно задать явно форму существительного в единственном числе

i) если нужно закешировать свойство то пометить его аннотацией
	@Getter( lazy=true)

j) для игнорирования свойства, назвать его с $
,и задать ему явно @NonFinal  тк ранее была применена аннотация @FieldDefaults
	 @NonFinal String $ item1
	 
 */
//</editor-fold>









/**
 * simple immutable class: String
 *
 * - pattern new-call
 * - not for inheritance
 *
 * <pre>{@code
 * //pattern new-call
 * 	  var  o = NonBlankString.of("Test");
 * 	  var o = NonBlankString.<String, String>builder().item1("f").build();
 * var b=o.compute();
 * }</pre>
 *
 *
 * Every constructor/fabric can raise the exceptions:
 * throws NullPointerException if argument nullable
 * throws IllegalArgumentException if argument empty
 */



@Value
@AllArgsConstructor( staticName = "of" )
@Builder( toBuilder = true )
@Slf4j
@Patterns /*pattern matching in vavr*/ public final class NonBlankString
	implements Comparable<NonBlankString>
	{
	
	
	
	private static final ResourceBundle bundle_        = ResourceBundle.getBundle( "messages" );
	
	
	
	private static final String         HELLO_MESSAGE_ = bundle_.getString( "hello" );
	
	
	
	/**
	 * item1
	 *
	 * -- SETTER --
	 *
	 * @param item1
	 * 	item1
	 * @return item1
	 *
	 * 	-- GETTER --
	 * 	the item1
	 */
	@NonNull private final String item1;
	
	
	
	/*
	pattern matching in vavr
	
	    - you need add static import to method with pattern matching
	    import static life.expert.value.string.NonBlankStringPatterns.*;	*/
	@Unapply
	static Tuple1<String> NonBlankString( NonBlankString object )
		{
		return Tuple.of( object.getItem1() );
		
		}
	
	
	//////////////////////////////////////////////////////////////////////////////////
	//  add your own methods
	//////////////////////////////////////////////////////////////////////////////////
	
	//<editor-fold desc=".">
	/*
	 *
	 * - в немутабельных классах используется функциональный подход:
	 * - операции немутабельного класса могут возвращать новый немутабельный объект
	 * например врзвращать немутабельный объект того же класса
	 *
	 *
	 *
	 *
	 * 2) количество параметров должно быть не более 4-х, иначе:
	 * - разбить метод на несколько (как например в NEW-SET-CALL для каждого параметра отдельный сетер)
	 * - вынести группу параметров в value-класс (nested static) (helper class)
	 * - все параметры зашить в паттерн билдер, где параметры можно присваивать по-очереди (так что билдер применим и на мутабельном объекте)
	 *
	 *
	 *
	 *
	 * <pre>{@code
	 *
	 *
	 * example 1
	 *            - генерирую runtime ошибки программирования
	 *            - генерирую runtime ошибки выполнения метода, если метод не вернет то что должен
	 *
	 *
	 * example 2
	 *
	 *           v_obj.f_method("test");
	 *
	 * example 3
	 *
	 *           - covariance: this overrided method can return subclass unstead class:
	 *                  resultSomeSuperclass f_method()
	 *                  resultSomeSubclass   f_overrided_method()
	 *
	 *
	 *  три варианта проверки входного аргумента
	 *  1) @NonNull   от LOMBOK
	 *  2) notBlank(string) notEmpty(collection)
	 *  3) optional
	 *
	 *
	 * }</pre> ПОМНИ СГЕНЕРИТЬ JAVADOC MAC8+fixDocComment И УБРАТЬ ЭТОТ ТЕКСТ
	 * */
	//</editor-fold>
	
	
	
	/**
	 * method f_method
	 *
	 * <pre>{@code
	 *           TestMutGen v_obj = new TestMutGen("Test");
	 *           TestMutGen v_obj = new TestMutGen();
	 *            }</pre>
	 *
	 * @throws IllegalArgumentException
	 * 	if argument empty  or null
	 */
	public Optional<String> compute( final String string )
		{
		if( string == null || string.isBlank() )
			{
			logAtWarning_( "string param must not ne null or empty" );
			return Optional.empty();
			}
		
		log_( "compute({})" , string );
		
		return Optional.ofNullable( string );
		}
		
		
		
	}
