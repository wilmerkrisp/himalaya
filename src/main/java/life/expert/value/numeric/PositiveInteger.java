package life.expert.value.string;



import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Singular;
import lombok.Value;
import lombok.extern.slf4j.Slf4j;
import lombok.NonNull;

import io.vavr.Tuple;
import io.vavr.Tuple1;
import io.vavr.match.annotation.Patterns;
import io.vavr.match.annotation.Unapply;

import java.util.Comparator;

import com.google.common.collect.ComparisonChain;

import java.util.List;

//---------------------------------------------
//      ___       __        _______   ______
//     /   \     |  |      /  _____| /  __  \
//    /  ^  \    |  |     |  |  __  |  |  |  |
//   /  /_\  \   |  |     |  | |_ | |  |  |  |
//  /  _____  \  |  `----.|  |__| | |  `--'  |
// /__/     \__\ |_______| \______|  \______/
//
//               wilmer 2019/08/08
//---------------------------------------------

import lombok.NonNull;//@NOTNULL

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import static java.text.MessageFormat.format;           //format string

import java.util.ResourceBundle;

import static com.google.common.base.Preconditions.*;   //checkArgument
//import static life.expert.common.base.Preconditions.*;  //checkCollection
import static org.apache.commons.lang3.Validate.*;      //notEmpty(collection)

import org.apache.commons.lang3.StringUtils;            //isNotBlank

import java.util.function.*;                            //producer supplier

import static java.util.stream.Collectors.*;            //toList streamAPI

import java.util.Optional;

import static reactor.core.publisher.Mono.*;
import static reactor.core.scheduler.Schedulers.*;
//import static  reactor.function.TupleUtils.*; //reactor's tuple->R INTO func->R
import static life.expert.common.function.TupleUtils.*; //vavr's tuple->R INTO func->R

import static life.expert.common.async.LogUtils.*;        //logAtInfo
import static life.expert.common.function.NullableUtils.*;//.map(nullableFunction)
import static life.expert.common.function.CheckedUtils.*;// .map(consumerToBoolean)
import static life.expert.common.reactivestreams.Preconditions.*; //reactive check
import static life.expert.common.reactivestreams.Patterns.*;    //reactive helper functions
import static life.expert.common.base.Objects.*;          //deepCopyOfObject
import static life.expert.common.reactivestreams.ForComprehension.*; //reactive for-comprehension

import static cyclops.control.Trampoline.more;
import static cyclops.control.Trampoline.done;

//import static io.vavr.API.*;                           //conflicts with my reactive For-comprehension

import static io.vavr.API.$;                            // pattern matching
import static io.vavr.API.Case;
import static io.vavr.API.Match;
import static io.vavr.Patterns.*;                         //switch - case - success/failure
import static io.vavr.Predicates.*;                       //switch - case
//import static java.util.function.Predicate.*;           //isEqual streamAPI

import static io.vavr.API.CheckedFunction;//checked functions
import static io.vavr.API.unchecked;    //checked->unchecked
import static io.vavr.API.Function;     //lambda->Function3
import static io.vavr.API.Tuple;

import static io.vavr.API.Try;          //Try

import io.vavr.control.Try;                               //try
import reactor.core.publisher.Mono;

import static io.vavr.API.Failure;
import static io.vavr.API.Success;
import static io.vavr.API.Left;         //Either
import static io.vavr.API.Right;

//import java.util.List;                                  //usual list
//import io.vavr.collection.List;                         //immutable List
//import com.google.common.collect.*;                     //ImmutableList

//@Header@
//--------------------------------------------------------------------------------
//
//                          himalaya  life.expert.value.string
//                           wilmer 2019/08/08
//
//--------------------------------------------------------------------------------

//<editor-fold desc=".">
 /*
    @Value означает
        @ToString
        @EqualsAndHashCode
        @AllArgsConstructor
        @FieldDefaults(makeFinal = true, level = AccessLevel.PRIVATE)
        @Getter
        
        
 
     d) IDE autogenerated Guava ComparisonChain, в сгенерированном методе compareTo необходимо заменить:
    		                      .compare( this.item2s ,
		                                that.item2s ,
		                                Ordering.< String > natural().lexicographical() )
		                                
		                                
		                                
		                                
  a) чтобы нельзя было отнаследовать и затереть данные подкласса ВЫБРАН ВАРИАНТ Б)
		вариант а) сделать класс final
		вариант  б) закрыть ВСЕ конструкторы и получать объекты только фабрикой
 
      b) You can use mutable variant of the class (companien class) for batch operations
 
 
 	 c) копирующие фабрики: для немутабельных классов нет смысла поддерживать копирование объектов, поскольку копии будут фактически неотличимы от оригинала.
	   - для немутабельных классов статические методы генерации копии имеют смысл, если получают на вход  параметр более общего интерфейса и мутабельный аргумент (см как в коллекциях Java)
	   - они называются conversion constructors / conversion factories
 
    
    e) нет конструкторов, только статик фабрика и builder
    
f) дефолтные значения свойств можно выставить
	@Builder.Default private final long created = System.currentTimeMillis();

g) как сделать withName метод (если поместить на весь класс - то будет сгенерено для всех методов класса )
	@Wither private final String name;

h) отдельный под-билдер для свойства-коллекции, имплементация будет Guava's ImmutableList
	@Singular  List<Line> ones; // на конце должно быть S, иначе не сможет сделать форму единственного числа
	@Singular("axis") List<Line> axes  // можно задать явно форму существительного в единственном числе

i) если нужно закешировать свойство то пометить его аннотацией
	@Getter( lazy=true)

j) для игнорирования свойства, назвать его с $
,и задать ему явно @NonFinal  тк ранее была применена аннотация @FieldDefaults
	 @NonFinal String $ item1
	 
 */
//</editor-fold>

/**
 * simple immutable class: int
 *
 * - pattern new-call
 * - not for inheritance
 *
 * <pre>{@code
 * //pattern new-call
 * 	  var  o = PositiveInteger.of("Test");
 * 	  var o = PositiveInteger.<String, String>builder().item1("f").build();
 * var b=o.compute();
 * }</pre>
 *
 *
 * Every constructor/fabric can raise the exceptions:
 * throws NullPointerException if argument nullable
 * throws IllegalArgumentException if argument empty
 */

@Value
@AllArgsConstructor( access = AccessLevel.PRIVATE )
@Patterns /*pattern matching in vavr*/
@Slf4j
public final class PositiveInteger
	implements Comparable<PositiveInteger>
	{
	
	/**
	 * item1
	 *
	 * -- SETTER --
	 *
	 * @param item1
	 * 	item1
	 * @return item1
	 *
	 * 	-- GETTER --
	 * @return item1
	 * 	the item1
	 */
	@NonNull private final int integer;
	
	@Deprecated
	public static PositiveInteger of( final int number )
		{
		return tryOf( number ).get();
		}
	
	public static Try<PositiveInteger> tryOf( final int number )
		{
		if( number < 1 )
			return illegalArgumentFailure( "Input argument must posititve >0 ." );
		else
			return Success( new PositiveInteger( number ) );
			
		}
	
	public static Optional<PositiveInteger> optionalOf( final int item1 )
		{
		return tryOf( item1 ).toJavaOptional();
		}
	
	public static Mono<PositiveInteger> monoOf( final int item1 )
		{
		return monoFromTry( tryOf( item1 ) );
		}
	
	@Unapply
	static Tuple1<Integer> PositiveInteger( PositiveInteger object )
		{
		return Tuple.of( object.getInteger() );
		}
	
	@Override
	public String toString()
		{
		return "" + this.integer;
		}
	
	@Override
	public int compareTo( PositiveInteger o )
		{
		return ComparisonChain.start()
		                      .compare( this.integer , o.integer )
		                      .result();
		}
	}
